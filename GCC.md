# GCC

GCC基本使用方法、常用指令

这个翻译过程分为四个阶段：预处理、编译、汇编和链接，通过使用不同参数可以选择执行不同的阶段。gcc的基本语法为：

gcc [options] [filenames]

其中options就是编译器所需要的参数，filenames给出相关的文件名称。

## 一步到位，直接生成可执行文件

```shell
gcc test.c -o test //如果未指定输出文件名称，默认输出为a.out。
```

## 预理阶段，将.c文件预处理为.i文件

这个过程处理宏定义和include，去除注释，不会对语法进行检查

```shell
gcc -E test.c -o test.i
```

### 预处理的过程主要处理包括以下过程

- 将所有的#define删除，并且展开所有的宏定义
- 处理所有的条件预编译指令，比如#if #ifdef #elif #else #endif等
- 处理#include 预编译指令，将被包含的文件插入到该预编译指令的位置。
- 删除所有注释 “//”和”/* */”.
- 添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号。
- 保留所有的#pragma编译器指令，因为编译器需要使用它们

## 2、编译阶段，生成汇编文件.s

这个阶段，通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。

```shell
gcc -S test.i
```

## 3、汇编阶段，将汇编文件编译为目标文件.o

-c，只编译，不链接成为可执行文件，编译器只是由输入的.c等源代码文件生成.o为后缀的目标文件，通常用于编译不包含主程序的子程序文件。（compile）

这个阶段，生成目标代码。此过程生成ELF格式的目标代码

汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。目标文件中所存放的也就是与源程序等效的目标的机器语言代码。 目标文件由段组成。通常一个目标文件中至少有两个段：

- 代码段(文本段)：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般不可写；
- 数据段：主要存放程序中要用到的各种常量、全局变量、静态的数据。一般数据段都是可读，可写，可执行的；

```shell
gcc -c test.s
```

## 4、链接阶段，生成可执行文件

-o output_filename，确定输出文件的名称为output_filename，同时这个名称不能和源文件同名。如果不给出这个选项，gcc就给出预设的可执行文件a.out。（output）

链接过程，生成可执行代码。链接分为两种，一种是静态链接，另外一种是动态链接。使用静态链接的好处是，依赖的动态链接库较少，对动态链接库的版本不会很敏感，具有较好的兼容性；缺点是生成的程序比较大。使用动态链接的好处是，生成的程序比较小，占用较少的内存。

```shell
gcc test.o -o test
```

### 静态库

#### 静态库的命名格式

```shell
lib + 库的名字 + .a
例：libMyTest.a (MyTest为静态库的名字）
```

#### 静态库作用分析

在项目开发过程中，经常出现优秀代码重用现象，又或者提供给第三方功能模块却又不想让其看到源代码，这些时候，通常的做法是将代码封装成库或者框架，生成的静态库要和头文件同时发布。

#### 优点

寻址方便，速度快
库在链接时被打包到可执行文件中，直接发布可执行程序即可以使用

#### 缺点

静态库的代码被加载到可执行程序中，因此体积过大
如果静态库的函数发生改变，必须重新编译可执行程序

### 动态库（共享库）

#### 动态库的命名格式

```shell
b + 库的名字 + .so
例：libMyTest.so (MyTest为动态库的名字）
```

#### 动态库作用分析

共享库的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。

#### 动态库优点

节省内存
易于更新，不用重新编译可执行程序，运行时自动加载

#### 动态库缺点

延时绑定，速度略慢

## 5、编译优化指令

有四个级别0~3,级别越高优化越好，但编译时间越长，中间代码可读性越差。0级无优化效果：

```shell
gcc -O1 test.c -o test
```
